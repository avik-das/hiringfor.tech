---
title: "Open book tests"
layout: edition
tags: interviewers
---

<figure id="cover-img" markdown="1">
![A complicated network of connected wires](/assets/images/posts/2020-08-31-open-book-tests.jpg)
<figcaption markdown="1">It's not about the knowledge that's online, but the connections you draw between that knowledge. Photo by [Alina Grubnyak](https://unsplash.com/@alinnnaaaa?utm_source=unsplash&utm_medium=referral&utm_content=creditCopyText) on [Unsplash](https://unsplash.com/s/photos/network?utm_source=unsplash&utm_medium=referral&utm_content=creditCopyText)
</figcaption>
</figure>

Be honest: how often do you use Stack Overflow, Mozilla Developer Network, or some other online resource? How effective would you be without these resources? I know my strength as developer is in understanding concepts and solving problems, not in memorizing APIs and algorithms. **So why do we test developers on their ability to come up with solutions without help?**

If you really want to evaluate candidates on the skills they will use in their job, you have two options.

## Reducing the dependence on memorization

First, you can test a candidate's problem solving skills. But if you do so, think about how developers actually solve high-level problems. The goal of this type of problem solving isn't to end up with working code, but set a direction for the architecture. That's why this type of interview problem is well-suited for system design interviews.

If you must write code, pick simple algorithms the candidate would actually develop on their own. Make sure APIs and syntax aren't part of the evaluation. In my experience, candidates often gravitate toward using Java or Python, but make it clear you'll accept pseudo-code. The structure of the solution is important, not the exact characters on the screen.

Finally, consider participating in [a back-and-forth with the candidate]({% post_url 2020-03-16-were-in-it-together %}). After all, most problem solving of this type happens collaboratively.

## Use the internet!

But all of this, is skirting around the real issue with contrived interview problems: developers don't really work like this. So, I suggest letting candidates [work on a real-world problem]({% post_url 2020-05-04-the-project-interview %}), and **let them have access to the internet**!

"But won't candidates be able to cheat?!" A developer's strength is in synthesizing solutions to the problems at hand. This entails mapping those problems to standard patterns they've seen, drawing inspiration from multiple sources, then putting it all together to solving the unique problem present at your company. Give candidates access to information, and see how they use it.

---

To effectively evaluate candidates on the skills they'll need on the job, let them work the same way they would after being hired. This means giving them access to the building blocks they'll use to solve your company's problems. After all, what good is it to hire someone who knows a piece of trivia but can't actually apply it?
